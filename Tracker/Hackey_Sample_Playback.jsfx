noindex: true
desc:Hackey Trackey Sample Playback Module (pre-alpha)
tags: tracker-style sampler
version: 0.70
author: Joep Vanlier
changelog: Include very basic autosplit functionality to Hackey Trackey Sample Playback.
license: MIT
about:
  # Hackey Tracker Sampler
  A small sampler designed to interoperate with Hackey Trackey.
  
  ### Usage instructions:
  This small JSFX acts as a sampler that interoperates with Hackey Trackey to 
  support tracker-like sample playback.
  
  Volume is sent on MIDI CC 9, while efects are sent on CC 12 (to indicate the 
  effect number) and CC 13 (to indicate the value). Note that due to the limitations 
  of the format, some concessions had to be made. Please read the effect list below 
  carefully and consider how this impacts your workflow.
  
  - Effect List
  01 - Portamento up
  02 - Portamento down
    Note that the portamento's behave different from Protracker. In PT you directly
    perform the portamento based on the period of the signal. Portamento is updated
    every N times per row (ticks).
    Here, the portamento slides continuously and the amount is specified in 
    eigth semitones. This means that 08 is 1 semitone. 10 is 2, etc.
    00 continues the last portamento.
  03 - Glide
    Glide to note. Glide speed is specified in 1/16th notes.
    00 Continues a previous glide.
  04 - Vibrato
    X is pitch depth (value from 0 to 7). They are given in seventh semitones.
    Y is speed (value from 0 to F).
      Continue, 128, 64, 32, 24, 16, 12, 8, 6, 5, 4, 3, 2, 1, 0.25, 0.125
    0 continues the previous value.
  08 - Panning
    Panning.
  09 - Set offset
    Unlike the classic Protracker, this sets offset as fraction of the sample length.
    Since 7F (127) is the maximum in MIDI; 40 is the middle of the sample, 20 1/4th etc.
  0A - Arpeggiator
    Arpeggiate. X and Y are note offsets in semitones. 0 continues previous value.
  0B - Retrigger
    Retrigger note.
    X - Volume reduction per trigger
    Y - Retrigger count
  0C - Sample probability
  60 - Reverse
    Reverses playhead if effect value is 00. Note that if this effect is applied on a 
    note start, it plays the sample from the end. If the effect is started from anywhere 
    else, it will simply reverse the playhead. When the effect is used with 01, hackey 
    tracker playback will return to forward playing.
    

options:gmem=saike_HT_sample
options:want_all_kb
options:no_meter
in_pin:left input
in_pin:right input
out_pin:left output 1
out_pin:right output 1
out_pin:left output 2
out_pin:right output 2
out_pin:left output 3
out_pin:right output 3
out_pin:left output 4
out_pin:right output 4
out_pin:left output 5
out_pin:right output 5
out_pin:left output 6
out_pin:right output 6
out_pin:left output 7
out_pin:right output 7
out_pin:left output 8
out_pin:right output 8
out_pin:left output 9
out_pin:right output 9
out_pin:left output 10
out_pin:right output 10
out_pin:left output 11
out_pin:right output 11
out_pin:left output 12
out_pin:right output 12
out_pin:left output 13
out_pin:right output 13
out_pin:left output 14
out_pin:right output 14
out_pin:left output 15
out_pin:right output 15
out_pin:left output 16
out_pin:right output 16

import htp_midi.jsfx-inc
import htp_sample_editor.jsfx-inc
options:maxmem=34000000

slider1:tracker=0<0,1,1{Buzz,Renoise}>-Key mapping
slider2:kb_layout=0<0,2,1{QWERTY,QWERTZ,AZERTY}>-Keyboard layout
slider3:multi_out=0<0,1,{Off,On}>-Multi-Out
slider4:select_by_notes=0<0,1,{Off,On}>-Choose sample by note
slider5:interpolation=1<0,3,1{Draft,Low,Medium,High}>Resampling quality

@init
init_sample_data_defaults();

font_color_r = font_color_g = font_color_b = 0.8;
font_color_a = 1.0;

waveform_r = .3;
waveform_g = .4;
waveform_b = .5;
waveform_a = 1.0;
box_rect_color_r = 0.02;
box_rect_color_g = 0.02;
box_rect_color_b = 0.02;
box_edge_color_r = 0.15;
box_edge_color_g = 0.15;
box_edge_color_b = 0.15;
selection_color_r = 0.1;
selection_color_g = 0.1;
selection_color_b = 0.5;
selection_color_a = 0.2;

dc_coeff = exp(-2*$pi*10/srate); // 10Hz cutoff

(ticks_per_beat == 0) ? ticks_per_beat = 4;

function char_to_pitch(ch)
global(tracker)
(
  (tracker == 0) ? (
    (ch == 122) ? ( 24 ) : (ch == 90) ? ( 24 ) : (ch == 120) ? ( 26 ) : (ch == 88) ? ( 26 ) : (ch == 99) ? ( 28 ) : (ch == 67) ? ( 28 ) : (ch == 118) ? ( 29 ) : (ch == 86) ? ( 29 ) : (ch == 98) ? ( 31 ) : (ch == 66) ? ( 31 ) : (ch == 110) ? ( 33 ) : (ch == 78) ? ( 33 ) : (ch == 109) ? ( 35 ) : (ch == 77) ? ( 35 ) : (ch == 115) ? ( 25 ) : (ch == 83) ? ( 25 ) : (ch == 100) ? ( 27 ) : (ch == 68) ? ( 27 ) : (ch == 103) ? ( 30 ) : (ch == 71) ? ( 30 ) : (ch == 104) ? ( 32 ) : (ch == 72) ? ( 32 ) : (ch == 106) ? ( 34 ) : (ch == 74) ? ( 34 ) : (ch == 113) ? ( 36 ) : (ch == 81) ? ( 36 ) : (ch == 119) ? ( 38 ) : (ch == 87) ? ( 38 ) : (ch == 101) ? ( 40 ) : (ch == 69) ? ( 40 ) : (ch == 114) ? ( 41 ) : (ch == 82) ? ( 41 ) : (ch == 116) ? ( 43 ) : (ch == 84) ? ( 43 ) : (ch == 121) ? ( 45 ) : (ch == 89) ? ( 45 ) : (ch == 117) ? ( 47 ) : (ch == 85) ? ( 47 ) : (ch == 105) ? ( 48 ) : (ch == 73) ? ( 48 ) : (ch == 111) ? ( 50 ) : (ch == 79) ? ( 50 ) : (ch == 112) ? ( 52 ) : (ch == 80) ? ( 52 ) : -1
  ) : ( tracker == 1 ) ? (
    (ch == 122) ? ( 24 ) : (ch == 90) ? ( 24 ) : (ch == 120) ? ( 26 ) : (ch == 88) ? ( 26 ) : (ch == 99) ? ( 28 ) : (ch == 67) ? ( 28 ) : (ch == 118) ? ( 29 ) : (ch == 86) ? ( 29 ) : (ch == 98) ? ( 31 ) : (ch == 66) ? ( 31 ) : (ch == 110) ? ( 33 ) : (ch == 78) ? ( 33 ) : (ch == 109) ? ( 35 ) : (ch == 77) ? ( 35 ) : (ch == 44) ? ( 36 ) : (ch == 44) ? ( 36 ) : (ch == 46) ? ( 38 ) : (ch == 46) ? ( 38 ) : (ch == 47) ? ( 40 ) : (ch == 47) ? ( 40 ) : (ch == 115) ? ( 25 ) : (ch == 83) ? ( 25 ) : (ch == 100) ? ( 27 ) : (ch == 68) ? ( 27 ) : (ch == 103) ? ( 30 ) : (ch == 71) ? ( 30 ) : (ch == 104) ? ( 32 ) : (ch == 72) ? ( 32 ) : (ch == 106) ? ( 34 ) : (ch == 74) ? ( 34 ) : (ch == 108) ? ( 37 ) : (ch == 76) ? ( 37 ) : (ch == 59) ? ( 39 ) : (ch == 59) ? ( 39 ) : (ch == 113) ? ( 36 ) : (ch == 81) ? ( 36 ) : (ch == 119) ? ( 38 ) : (ch == 87) ? ( 38 ) : (ch == 101) ? ( 40 ) : (ch == 69) ? ( 40 ) : (ch == 114) ? ( 41 ) : (ch == 82) ? ( 41 ) : (ch == 116) ? ( 43 ) : (ch == 84) ? ( 43 ) : (ch == 121) ? ( 45 ) : (ch == 89) ? ( 45 ) : (ch == 117) ? ( 47 ) : (ch == 85) ? ( 47 ) : (ch == 105) ? ( 48 ) : (ch == 73) ? ( 48 ) : (ch == 111) ? ( 50 ) : (ch == 79) ? ( 50 ) : (ch == 112) ? ( 52 ) : (ch == 80) ? ( 52 ) : (ch == 91) ? ( 53 ) : (ch == 91) ? ( 53 ) : (ch == 93) ? ( 55 ) : (ch == 93) ? ( 55 ) : (ch == 50) ? ( 37 ) : (ch == 50) ? ( 37 ) : (ch == 51) ? ( 39 ) : (ch == 51) ? ( 39 ) : (ch == 53) ? ( 42 ) : (ch == 53) ? ( 42 ) : (ch == 54) ? ( 44 ) : (ch == 54) ? ( 44 ) : (ch == 55) ? ( 46 ) : (ch == 55) ? ( 46 ) : (ch == 57) ? ( 49 ) : (ch == 57) ? ( 49 ) : (ch == 48) ? ( 51 ) : (ch == 48) ? ( 51 ) : (ch == 61) ? ( 54 ) : (ch == 61) ? ( 54 ) : -1
  );
);

function get_pitch_from_kb(kb)
global(kb_layout)
(
  kb_layout == 0 ? (
    char_to_pitch(kb)
  ) : ( kb_layout == 1 ) ? (
    char_to_pitch((kb == 122) ? ( 121 ) : (kb == 121) ? ( 122 ) :  (kb == 90) ? ( 89 ) : (kb == 89) ? ( 90 ) : kb)
  ) : (
    char_to_pitch((kb == 97) ? ( 113 ) : (kb == 113) ? ( 97 ) :  (kb == 65) ? ( 81 ) : (kb == 81) ? ( 65 ) :  (kb == 122) ? ( 119 ) : (kb == 119) ? ( 122 ) :  (kb == 90) ? ( 87 ) : (kb == 87) ? ( 90 ) :  (kb == 109) ? ( 59 ) : (kb == 59) ? ( 109 ) :  (kb == 77) ? ( 59 ) : (kb == 59) ? ( 77 ) : kb)
  );
);

function set_pan(pan)
local(p)
global()
instance(lpan, rpan)
(
  pan > 0.99 ? pan = 1;
  p = 0.5 * $pi * pan;
  lpan = cos(p);
  rpan = sin(p);
);

function stop_playback()
instance(x_fade_position)
global(crossfade_samples)
(
  x_fade_position = - crossfade_samples;
);

function stop_sample()
instance(current_playback)
global()
(
  (current_playback == 1) ? (
    this.play1.stop_playback();
  ) : (
    this.play0.stop_playback();
  );
);

function chan_default(idx)
instance(vol, chan)
global()
local()
(
  vol = 1;
  chan = idx;
  this.set_pan(0.5);
);

<? function all_channels(txt) 
local(i) (
  i = 1;
  loop(16,
    printf(txt, i, i, i, i, i, i);
    printf("\n");
    i = i+1;
  );
)?>

!initialized ? (
 <? all_channels("chan%d.chan_default(%d);") ?>
 preview_channel.chan_default(17);
 initialized = 1;
 last_selected_sample = -1337;
);

<? all_channels("chan%d.stop_sample(%d);") ?>
preview_channel.stop_sample();

/* Choose interpolation kernel for sample player */

function set_speed(new_speed)
instance(speed, sinc_table, table_len, at_base_rate)
global(sinc_tables)
local(pitch_ratio)
(
  pitch_ratio = abs(new_speed);
  at_base_rate = 0;

  pitch_ratio != abs(speed) ? (
    pitch_ratio < 0.125 ? (
      sinc_table = sinc_tables[0]+1;
      table_len = sinc_tables[0][0];
    ) :
    pitch_ratio <= 0.5 ? (
      sinc_table = sinc_tables[1]+1;
      table_len = sinc_tables[1][0];
    ) :
    pitch_ratio <= 1 ? (
      sinc_table = sinc_tables[2]+1;
      table_len = sinc_tables[2][0];
      pitch_ratio == 1 ? at_base_rate = 1;
    ) :
    pitch_ratio <= 1.414214 ? (
      sinc_table = sinc_tables[3]+1;
      table_len = sinc_tables[3][0];
    ) :
    pitch_ratio <= 2.0 ? (
      sinc_table = sinc_tables[4]+1;
      table_len = sinc_tables[4][0];
    ) :
    pitch_ratio <= 2.828427 ? (
      sinc_table = sinc_tables[5]+1;
      table_len = sinc_tables[5][0];
    ) :
    pitch_ratio <= 4.0 ? (
      sinc_table = sinc_tables[6]+1;
      table_len = sinc_tables[6][0];
    ) :
    pitch_ratio <= 5.656854 ? (
      sinc_table = sinc_tables[7]+1;
      table_len = sinc_tables[7][0];
    ) :
    pitch_ratio <= 8.0 ? (
      sinc_table = sinc_tables[8]+1;
      table_len = sinc_tables[8][0];
    ) :
    pitch_ratio <= 11.313708 ? (
      sinc_table = sinc_tables[9]+1;
      table_len = sinc_tables[9][0];
    ) :
    pitch_ratio <= 16.0 ? (
      sinc_table = sinc_tables[10]+1;
      table_len = sinc_tables[10][0];
    ) :
    pitch_ratio <= 22.627417 ? (
      sinc_table = sinc_tables[11]+1;
      table_len = sinc_tables[11][0];
    ) :
    pitch_ratio <= 32 ? (
      sinc_table = sinc_tables[12]+1;
      table_len = sinc_tables[12][0];
    ) : (
      sinc_table = sinc_tables[13]+1;
      table_len = sinc_tables[13][0];
    );
  );
  
  speed = new_speed;
);

function start_playback(buffer_loc, playspeed, offset)
instance(start_ptr, x_fade_position, playing, fade_start, position, speed,
         loop_start, loop_stop, loop_type, stop_position)
global(crossfade_samples, SAMPLE_HEADER)
local(len)
(
  len = buffer_loc[];
  stop_position = len / 2 - 2;
  fade_start = buffer_loc + buffer_loc[] + SAMPLE_HEADER - 2 * playspeed * crossfade_samples;
  start_ptr = buffer_loc + SAMPLE_HEADER;
  
  loop_start = buffer_loc[3];
  loop_stop = buffer_loc[4];
  loop_type = buffer_loc[5];
  
  x_fade_position = crossfade_samples;
  position = offset;
  playing = 1;
  this.set_speed(playspeed);
);

function update_loop_parameters(buffer_loc)
instance(loop_start, loop_stop, loop_type)
(
  loop_start = buffer_loc[3];
  loop_stop = buffer_loc[4];
  loop_type = buffer_loc[5];
  
  // If we are not looping or looping forward, make sure we're not going back
  // in time (which could happen if we were coming from a bidi loop and would
  // result in a loud click if we move past the start of the sample (it has
  // the length there).
  ((loop_type == 0) || (loop_start == -1)) ? (
    speed = abs(speed);
  );
);

/* downsampling FIR filter */
function downsample_fir(x0,x1)
instance ( <? i=0; loop(13, printf("ex%d, ", i); i+=1;) ?> // even taps
           <? i=0; loop(24, printf("ox%d, ", i); i+=1;) ?> ) // odd taps
(
  <? i=12; loop(12, printf("ex%d = ex%d; ", i, i-1); i-=1;) ?>
  <? i=23; loop(23, printf("ox%d = ox%d; ", i, i-1); i-=1;) ?>
  ex0 = x0; ox0 = x1;
   -0.00410257623761148*(ox0+ox23) +
    0.00395055104797943*(ox1+ox22) +
   -0.00580787578939173*(ox2+ox21) +
    0.00823497890520802*(ox3+ox20) +
   -0.0113722265131996*(ox4+ox19) +
    0.01547155714097370*(ox5+ox18) +
   -0.0209449963986892*(ox6+ox17) +
    0.0285680781320342*(ox7+ox16) +
   -0.0400151439056141*(ox8+ox15) +
    0.0596695194318312*(ox9+ox14) +
   -0.103669138691865*(ox10+ox13) +
    0.317491986549921*(ox11+ox12) +
    0.5*ex12;
);

function reset_fir()
instance ( <? i=0; loop(13, printf("ex%d, ", i); i+=1;) ?> // even taps
           <? i=0; loop(24, printf("ox%d, ", i); i+=1;) ?> ) // odd taps
(
  <? i=0; loop(13, printf("ex%d=0; ", i); i+=1;) ?> // even taps
  <? i=0; loop(24, printf("ox%d=0; ", i); i+=1;) ?> // odd taps
);

/* Sinc interpolated resampling */

function sinc_interp(start_ptr, position, channel)
instance(sinc_table, table_len, at_base_rate)
local(phase, idx, frac, val0, val1, sample_ptr, table_ptr)
global(KERNEL_PHASES)
(
  idx = floor(position);
  frac = position - idx;
  phase = floor(frac * KERNEL_PHASES);

  frac == 0 && at_base_rate ?
    start_ptr[2*idx + channel]
  : idx >= table_len*0.5 ? (
    sample_ptr = start_ptr + 2*idx - table_len + channel;
    table_ptr = sinc_table + 2*phase*table_len;
    mem_multiply_sum(sample_ptr, table_ptr, 2 * table_len);
  ) : (
    sample_ptr = start_ptr + channel;
    table_ptr = sinc_table + 2*phase*table_len + table_len - 2 * idx;
    mem_multiply_sum(sample_ptr, table_ptr, table_len + 2 * idx);
  );
);

/* Sample play (each channel has two of these guys that alternate) */
function play()
instance(start_ptr, read_ptr, x_fade_position, fade_start,
         outL, outR, playing, fade_level, position, speed,
         loop_start, loop_stop, loop_type,
         portamento_len, portamento_ds, vib_len,
         vib_depth, vib_speed, vib_phase, stop_position,
         sinc_table, table_len)
global(fade_in_samples, fade_out_samples, interpolation, play_state)
local(frac, ism1, is0, is1, is2, id0, id1, id2, id3, fade_fraction)
(
  // Positive fade means fading in
  (x_fade_position > 0.01) ? (
    fade_level = 1.0 - sqrt(0.5 - 0.5 * cos(x_fade_position * pi_inv_crossfade_samples));
    x_fade_position -= 1;
  // Negative fade means fading out
  ) : (x_fade_position < -0.01) ? (
    fade_level = sqrt(0.5 - 0.5 * cos(- x_fade_position * pi_inv_crossfade_samples));
    x_fade_position += 1;
    ((x_fade_position == 0) || (position > stop_position)) ? (
      playing = (interpolation > 1 ? -26 : 0); // Terminate playback after this number of samples
      vib_len = 0;
      portamento_len = 0;
      speed = 0;
    );
  ) : (playing > 0) ? (
    // Fade out if we're approaching the end of the recorded sample
    fade_level = 1;
    (loop_start > 0) ? (
      (loop_type == 0) ? (
        (position > loop_stop) ? position -= (loop_stop - loop_start);
      ) : (
        (position > loop_stop) ? (
          speed = - speed;
        ) : ( position < loop_start ) ? (
          speed = abs(speed);
        );
      );
    ) : (
      (read_ptr > fade_start) ? (
        x_fade_position = - crossfade_samples;
      );
    );
  );
  
  
  playing > 0 ? (
    (interpolation == 0) ? (
      frac = position - floor(position);
      read_ptr = start_ptr + 2 * floor(position) - 2;
      outL = fade_level*(read_ptr[] * (1.0 - frac) + frac * read_ptr[2]);
      outR = fade_level*(read_ptr[1] * (1.0 - frac) + frac * read_ptr[3]);
    ) : (interpolation == 1) ? (
      frac = position - floor(position);
      read_ptr = start_ptr + 2 * floor(position) - 8;
      ism1 = read_ptr[];
      is0 = read_ptr[2];
      is1 = read_ptr[4];
      is2 = read_ptr[6];
      
      id0 = is0;
      id1 = 0.5*(is1 - ism1);
      id2 = ism1 - 2.5*is0 + 2*is1 - 0.5*is2;
      id3 = 0.5*(is2 - ism1) + 1.5 * (is0 - is1);
      outL = fade_level*(((id3*frac+id2)*frac+id1)*frac+id0);
      
      ism1 = read_ptr[1];
      is0 = read_ptr[3];
      is1 = read_ptr[5];
      is2 = read_ptr[7];
      
      id0 = is0;
      id1 = 0.5*(is1 - ism1);
      id2 = ism1 - 2.5*is0 + 2*is1 - 0.5*is2;
      id3 = 0.5*(is2 - ism1) + 1.5 * (is0 - is1);
      outR = fade_level*(((id3*frac+id2)*frac+id1)*frac+id0);
    ) : (interpolation == 2) ? (
      read_ptr = start_ptr + 2 * floor(position);
      outL = fade_level*this.sinc_interp(start_ptr, position, 0);
      outR = fade_level*this.sinc_interp(start_ptr, position, 1);
    ) : (interpolation > 2) ? (
      read_ptr = start_ptr + 2 * floor(position);
      speed <= 1 ? (
        outL = this.left.downsample_fir(2*fade_level*this.sinc_interp(start_ptr, position, 0), 0);
        outR = this.right.downsample_fir(2*fade_level* this.sinc_interp(start_ptr, position, 1), 0);
      ) : (
        outL = this.left.downsample_fir(fade_level*this.sinc_interp(start_ptr, position, 0), 
                                      fade_level*this.sinc_interp(start_ptr, position+speed/2, 0));
        outR = this.right.downsample_fir(fade_level*this.sinc_interp(start_ptr, position, 1), 
                                      fade_level*this.sinc_interp(start_ptr, position+speed/2, 1));
      );
    );
  ) : (playing < 0) ? (
    playing += 1;
    outL = this.left.downsample_fir(0,0);
    outR = this.right.downsample_fir(0,0);
  );
  
  (vib_len > 0) ? (
    (vib_len == 1) ? ( vib_phase = -1337; )
    : (
      vib_phase += vib_speed;
      (vib_phase > 1) ? vib_phase -= 2;
      position += speed * exp(vib_depth * (2 * abs(vib_phase) - 1));
    );
    vib_len -= 1;
  ) : (
    position += speed;
  );
  
  portamento_len > 0 ? (
    portamento_len -= 1;
    this.set_speed(speed * portamento_ds);
  );
  
  fade_level
);

/* Channel play */
function prepare_channel_for_messages()
instance(offset, got_note, effect, effect_value)
global()
local()
(
  offset = 0;
  got_note = 0;
  effect_value = -1;
);

function schedule_note(new_sample_idx, new_pitch)
instance(got_note, sample_idx, pitch)
local()
global()
(
  pitch = new_pitch;
  sample_idx = new_sample_idx;
  got_note = 1;
);

function schedule_stop()
instance(got_note)
local()
global()
(
  (got_note == 0) ? ( got_note = -1; );
);

function pitch_to_speed(sample_location, pitch)
local(fs, fnote, r_speed, speed)
global(srate)
(
  fs = sample_location[1];
  fnote = sample_location[2];
  r_speed = 2^((pitch - fnote)/12);
  speed = r_speed * (fs / srate);
);

function vibrato_speed(speed_idx)
local()
global()
(
  (speed_idx == 1) ? ( 0.0625 ) : (speed_idx == 2) ? ( 0.08333333333333333 ) : (speed_idx == 3) ? ( 0.125 ) : (speed_idx == 4) ? ( 0.16666666666666666 ) : (speed_idx == 5) ? ( 0.25 ) : (speed_idx == 6) ? ( 0.3333333333333333 ) : (speed_idx == 7) ? ( 0.4 ) : (speed_idx == 8) ? ( 0.5 ) : (speed_idx == 9) ? ( 0.6666666666666666 ) : (speed_idx == 10) ? ( 1.0 ) : (speed_idx == 11) ? ( 1.3333333333333333 ) : (speed_idx == 12) ? ( 2.0 ) : (speed_idx == 13) ? ( 4.0 ) : (speed_idx == 14) ? ( 8.0 ) : (speed_idx == 15) ? ( 16.0 )
);

function commit_note()
instance(current_playback, sample_location, speed, offset,
         got_note, effect_value, effect,
         last_porta,
         last_arp_1, last_arp_2,
         last_vib_speed, last_vib_depth,
         vol, chan,
         pitch, sample_idx,
         note_schedule, note_schedule_ptr, next_backlog,
         playing)
global(samples_per_beat, samplelocs, blocked_samples, srate)
local(vol_change,
      portamento_ds, curspeed, portamento_len, count, cv, dt,
      vib_depth, vib_speed)
(
  note_schedule[] = -1337;

  (effect == 12) ? (
    (rand() > (effect_value / 127)) ? got_note = 0;
  );

  // Warning: this is a regression waiting to happen. Glide disables
  // note offs, but should not disable pitch computation from happening
  // since this is needed to know where to go.
  got_note ? (
    sample_location = samplelocs[sample_idx];
    this.set_speed(pitch_to_speed(sample_location, pitch));
  );

  /* If no effect value is set, don't use one */
  (effect_value == -1) ? effect = -1;

  // Start from end of sample if we are dealing with a reverse on a note start.
  (effect == 96 && effect_value == 0) ? offset = 1;

  (effect == 9) ? (offset = effect_value / 127;);
  
  // Glide disables the note on and off. See note on got_note above.
  (effect == 3) ? ( got_note = 0; );
  
  // Check whether this has a valid samplerate
  (got_note > 0) ? (
    sample_location[1] > 90 ? (
      (current_playback == 1) ? (
        (!blocked_samples[sample_idx] || (chan == 17)) ? (
          this.play0.start_playback(sample_location, speed, 0.5 * offset * sample_location[]);
        );
        this.play1.stop_playback();
      ) : (
        (!blocked_samples[sample_idx] || (chan == 17)) ? (
          this.play1.start_playback(sample_location, speed, 0.5 * offset * sample_location[]);
        );
        this.play0.stop_playback();
      );
      current_playback = 1.0 - current_playback;
    );
  ) : ( got_note < 0 ) ? (
    // No note, but a stop signal, then terminate the sample.
    this.stop_sample();
  );
  
  // Set portamento for upcoming row
  ((effect == 1) || (effect == 2)) ? (
    (effect_value == 0) ? effect_value = last_porta;
    // Semitone given by effect_value / 8. Hence 2^(value / (8*12))
    (effect == 1) ? (
      portamento_ds = 2^(effect_value / (8*12 * samples_per_beat));
    ) : (
      portamento_ds = 2^(-effect_value / (8*12 * samples_per_beat));
    );

    (current_playback == 0) ? (
      this.play0.portamento_len = samples_per_beat;
      this.play0.portamento_ds = portamento_ds;
    ) : (
      this.play1.portamento_len = samples_per_beat;
      this.play1.portamento_ds = portamento_ds;
    );
    last_porta = effect_value;
  );
  
  (effect == 4) ? (
    // The log 2 is to make sure we can use exp, instead of 2^in the sample function.
    count = effect_value / 16;
    vib_depth = count > 1 ? log(2) * floor(count) / (7 * 12) : last_vib_depth;
    count = effect_value % 16;
    vib_speed = count > 1 ? vibrato_speed(count) / samples_per_beat : last_vib_speed;
    
    (current_playback == 0) ? (
      (this.play0.vib_phase < -1336) ? this.play0.vib_phase = 0.5;
      this.play0.vib_depth = vib_depth;
      this.play0.vib_speed = vib_speed;
      this.play0.vib_len = samples_per_beat + 2;
    ) : (
      (this.play1.vib_phase < -1336) ? this.play1.vib_phase = 0.5;
      this.play1.vib_depth = vib_depth;
      this.play1.vib_speed = vib_speed;
      this.play1.vib_len = samples_per_beat + 2;
    );
    
    last_vib_speed = vib_speed;
    last_vib_depth = vib_depth;
  );
  
  (effect == 8) ? (
    this.set_pan(effect_value/128);
  );
  
  // Glide
  (effect == 3) ? (
    (effect_value == 0) ? effect_value = last_porta;
    curspeed = (current_playback == 0) ? this.play0.speed : this.play1.speed;
    portamento_ds = 2^(sign(speed - curspeed) * effect_value / (8 * 12 * samples_per_beat));
    portamento_len = min((log(speed) - log(curspeed)) / log(portamento_ds), samples_per_beat);
    (current_playback == 0) ? (
      this.play0.portamento_len = portamento_len;
      this.play0.portamento_ds = portamento_ds;
    ) : (
      this.play1.portamento_len = portamento_len;
      this.play1.portamento_ds = portamento_ds;
    );
    last_porta = effect_value;
  );
  
  (effect == 96) ? (
    (current_playback == 0) ? (
      (effect_value == 0) ? (
        this.play0.speed = - abs(this.play0.speed);
      ) : (
        this.play0.speed = abs(this.play0.speed);
      );
    ) : (
      (effect_value == 0) ? (
        this.play1.speed = - abs(this.play1.speed);
      ) : (
        this.play1.speed = abs(this.play1.speed);
      );
    );
  );
  
  // Arpeggiator
  (effect == 10) ? (
    count = floor(effect_value / 16);
    count > 0 ? last_arp_1 = count;
    
    count = effect_value % 16;
    count > 0 ? last_arp_2 = count;
    
    dt = floor(samples_per_beat / 3);
    (current_playback == 1) ? (
      this.play1.set_speed(pitch_to_speed(sample_location, pitch));
    ) : (
      this.play0.set_speed(pitch_to_speed(sample_location, pitch));
    );
    
    note_schedule_ptr = note_schedule;
    note_schedule_ptr[] = dt; note_schedule_ptr += 1;
    note_schedule_ptr[] = vol; note_schedule_ptr += 1; // Volume
    note_schedule_ptr[] = sample_idx; note_schedule_ptr += 1; // Sample
    note_schedule_ptr[] = - pitch - last_arp_1; note_schedule_ptr += 1; // Pitch
    
    note_schedule_ptr[] = dt; note_schedule_ptr += 1;
    note_schedule_ptr[] = vol; note_schedule_ptr += 1; // Volume
    note_schedule_ptr[] = sample_idx; note_schedule_ptr += 1; // Sample
    note_schedule_ptr[] = - pitch - last_arp_2; note_schedule_ptr += 1; // Pitch
    
    note_schedule_ptr[] = dt; note_schedule_ptr += 1;
    note_schedule_ptr[] = vol; note_schedule_ptr += 1; // Volume
    note_schedule_ptr[] = sample_idx; note_schedule_ptr += 1; // Sample
    note_schedule_ptr[] = - pitch; note_schedule_ptr += 1; // Pitch
    
    note_schedule_ptr[] = -1337;
    
    next_backlog = dt;
    note_schedule_ptr = note_schedule;
  );
  
  // Retrigger
  (effect == 11) ? (
    note_schedule_ptr = note_schedule;
    
    vol_change = (1.0 - floor(effect_value / 16) / 8);
    count = effect_value % 16;
    dt = floor(samples_per_beat / (count + 1));
    cv = vol * vol_change;
    loop(count,
      note_schedule_ptr[] = dt; note_schedule_ptr += 1;
      note_schedule_ptr[] = cv; note_schedule_ptr += 1; // Volume
      cv *= vol_change;
      note_schedule_ptr[] = sample_idx; note_schedule_ptr += 1; // Sample
      note_schedule_ptr[] = pitch; note_schedule_ptr += 1; // Pitch
    );
    // Finalize with the volume after the trigger.
    note_schedule_ptr[] = dt - 1; note_schedule_ptr += 1;
    note_schedule_ptr[] = vol; note_schedule_ptr += 1;
    note_schedule_ptr[] = -1337;
    
    next_backlog = dt;
    note_schedule_ptr = note_schedule;
  );
  
  playing = this.play0.playing || this.play1.playing;
);

function set_offset_raw(offset)
local()
instance(current_playback)
(
  (current_playback == 1) ? (
    this.play1.position = offset
  ) : (
    this.play0.position = offset
  );
);

function play_sample(sample_idx, new_pitch, offset)
instance(current_playback)
global(samplelocs)
local()
(
  new_pitch > 0 ? (
    this.prepare_channel_for_messages();
    this.schedule_note(sample_idx, new_pitch);
    this.offset = offset;
    this.commit_note();
  ) : (
    (current_playback == 1) ? (
      this.play1.set_speed(pitch_to_speed(samplelocs[sample_idx], -new_pitch));
    ) : (
      this.play0.set_speed(pitch_to_speed(samplelocs[sample_idx], -new_pitch));
    );
  );
);

/* Channel update loop */
function channel_update_loop()
instance(current_playback, sample_location)
global()
local()
(
  (current_playback == 0) ? (
    this.play0.update_loop_parameters(sample_location);
  ) : (
    this.play1.update_loop_parameters(sample_location);
  );
);

function handle_message(msg1, msg2, msg3)
instance(vol, effect, effect_value)
local(cc_msg)
global(N_SAMPLES, select_by_notes)
(
  (msg1>$x8F && msg1<$xA0 && msg3!=0) ? (
    // Note on?
    select_by_notes ? (
      (msg2 - 60) < N_SAMPLES ? (
        this.schedule_note(msg2 - 60, 69);
      )
    ) : (
      (msg3 < N_SAMPLES) ? (
        this.schedule_note(msg3 - 1, msg2); /* msg3 = velocity which serves as note now ; msg2 is pitch */
      );
    );
  ) : ( (msg1>$x7F && msg1<$x90) || (msg1>$x89&&msg1<$xA0 && msg3==0 ) ) ? (
    // Note off
    this.schedule_stop();
  ) : (msg1>$xAF && msg1<$xC0) ? (
    // Set volume
    cc_msg = msg2 & 127;
    (cc_msg == 7) ? (
      vol = (msg3 & 127) / 127;
      vol *= vol;  // Square volume
    ) : (cc_msg == 12) ? (
      effect = msg3 & 127;
    ) : (cc_msg == 13) ? (
      effect_value = msg3 & 127;
    );
  );
);

function processBacklog()
instance(note_schedule, note_schedule_ptr, next_backlog, vol)
local(sample_idx)
global()
(
  // Count down to the next item
  next_backlog -= 1;
    
  // FIRE!
  next_backlog == 0 ? (
    // What channel is this?
    note_schedule_ptr += 1; // Go past the count
    vol = note_schedule_ptr[]; note_schedule_ptr += 1;
      
    // Is there a note here or not?
    sample_idx = note_schedule_ptr[];
    (sample_idx > -1) ? (
      note_schedule_ptr += 1;
      this.play_sample(sample_idx, note_schedule_ptr[], 0);
      note_schedule_ptr += 1;
    );
      
    // Proceed to the next one
    next_backlog = note_schedule_ptr[];
  );
);

function play_channel()
instance(vol, cleft, cright, lpan, rpan, next_backlog, xL, yL, xR, yR)
global(ssl, ssr, dc_coeff)
local(temp)
(
  next_backlog > 0 ? ( this.processBacklog() );

  cleft = 0.998 * cleft + 0.002 * lpan * vol;
  cright = 0.998 * cright + 0.002 * rpan * vol;
  
  this.play0.playing ? (
    this.play0.play();
    ssl += this.play0.outL * cleft;
    ssr += this.play0.outR * cright;
  );
  this.play1.playing ? (
    this.play1.play();
    ssl += this.play1.outL * cleft;
    ssr += this.play1.outR * cright;
  );
  
  // DC filter at 10Hz
  
  temp = ssl;
  ssl -= xL - dc_coeff * yL;
  yL = ssl;
  xL = temp;
  
  temp = ssr;
  ssr -= xR - dc_coeff * yR;
  yR = ssr;
  xR = temp;
);

function initNoteSchedule(mem)
local()
global()
instance(note_schedule)
(
  note_schedule = mem;
  note_schedule[] = -1337;
  mem + 256;
);

KERNEL_PHASES = 256;

function sinc(x)
(
  x == 0 ? 1 : sin($pi * x) / ($pi * x);
);

function i0_approx(x)
local(sum, term, k, xh) (
  sum = 1;
  term = 1;
  xh = 0.5 * x;
  k = 1;
  while (k<=40 && term > 10^-12) (
    term *= (xh * xh) / (k * k);
    sum += term;
    k += 1;
  );
  sum;
);


function build_sinc_table(mem, length, cutoff) 
local(phase, frac, sum, tap, window, x, denom, alpha)
global(KERNEL_PHASES)
(
  phase = 0;
  denom = i0_approx(8);
  
  mem[0] = length; // store length as first entry
  mem += 1;

  loop(KERNEL_PHASES,
    frac = phase / KERNEL_PHASES;
    sum = 0;
    tap = 0;
    alpha = (length - 1)*0.5;
    loop(length,
      // Kaiser
      x = (tap - alpha) / alpha;
      window = i0_approx(8*sqrt(max(0,1-x*x))) / denom;
      
      x = tap - frac - floor(length/2);
      mem[2*tap] = sinc(x * cutoff) * window;
      mem[2*tap + 1] = 0.0;
      // zero-pad so we can use with interleaved stereo

      sum += mem[2*tap];
      tap += 1;
    );

    // Normalize
    tap = 0;
    loop(length,
      mem[2*tap] /= sum;
      tap += 1;
    );

    phase += 1;
    mem += 2 * length;
  );

  mem;
);

function build_all_sinc_tables(mem)
local(table, ratio, nextmem, scale)
global(sinc_tables, srate,interpolation)
(
  sinc_tables = mem;
  nextmem = mem + 14;
  scale = 40000/srate;
  
  interpolation < 3 ? ( 
    sinc_tables[0]  = nextmem;
    nextmem = build_sinc_table(nextmem, 64, 1);               // pitch < 0.125
    sinc_tables[1]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, 1);               // pitch 0.125 .. 0.5
    sinc_tables[2]  = nextmem;
    nextmem = build_sinc_table(nextmem, 16, 1);               // pitch 0.5 .. 1
    sinc_tables[3]  = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/sqrt(2));           // pitch 1 .. srqt(2)
    sinc_tables[4]  = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/2);   // pitch sqrt(2) .. 2
    sinc_tables[5]  = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/2/sqrt(2));         // pitch 2 .. 2*sqrt(2)
    sinc_tables[6]  = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/4); // pitch 2*sqrt(2) .. 4
    sinc_tables[7]  = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/4/sqrt(2));         // pitch 4 .. 4*sqrt(2)
    sinc_tables[8]  = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/8);  // pitch 4*sqrt(2) .. 8
    sinc_tables[9]  = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/8/sqrt(2));          // pitch 8 .. 8*sqrt(2)
    sinc_tables[10] = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/16);  // pitch 8*sqrt(2) .. 16
    sinc_tables[11] = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/16/sqrt(2));          // pitch 16 .. 16*sqrt(2)
    sinc_tables[12] = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/32);  // pitch 16*sqrt(2) .. 32
    sinc_tables[13] = nextmem;
    nextmem = build_sinc_table(nextmem, 16, scale/32/sqrt(2));         // pitch > 32
  ) : interpolation == 3 ? (
    sinc_tables[0]  = nextmem;
    nextmem = build_sinc_table(nextmem, 128, 1);              // pitch < 0.125
    sinc_tables[1]  = nextmem;
    nextmem = build_sinc_table(nextmem, 64, 1);               // pitch 0.125 .. 0.5
    sinc_tables[2]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, 1);               // pitch 0.5 .. 1
    sinc_tables[3]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale);           // pitch 1 .. srqt(2)
    sinc_tables[4]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/sqrt(2));   // pitch sqrt(2) .. 2
    sinc_tables[5]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/2);         // pitch 2 .. 2*sqrt(2)
    sinc_tables[6]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/2/sqrt(2)); // pitch 2*sqrt(2) .. 4
    sinc_tables[7]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/4);         // pitch 4 .. 4*sqrt(2)
    sinc_tables[8]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/4/sqrt(2)); // pitch 4*sqrt(2) .. 8
    sinc_tables[9]  = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/8);         // pitch 8 .. 8*sqrt(2)
    sinc_tables[10] = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/8/sqrt(2)); // pitch 8*sqrt(2) .. 16
    sinc_tables[11] = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/16);         // pitch 16 .. 16*sqrt(2)
    sinc_tables[12] = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/16/sqrt(2)); // pitch 16*sqrt(2) .. 32
    sinc_tables[13] = nextmem;
    nextmem = build_sinc_table(nextmem, 32, scale/32);        // pitch > 32
  );
  
  nextmem;
);

freemem = 0;

// Sample locations are recorded as [64 byte header (first is length), sampledata]
freemem = (samplelocs = freemem) + 128;
idx = 0;
loop(N_SAMPLES,
  freemem = (samplelocs[idx] = freemem) + SAMPLE_SIZE;
  idx += 1;
);

freemem = (scratchloc = freemem) + SAMPLE_SIZE;
freemem = (copyloc = freemem) + SAMPLE_SIZE;
freemem = (undo_memory = freemem) + SAMPLE_SIZE + 64;

freemem = (midimem = freemem) + 32768;
midi.initializeMIDI(midimem, 1, 1);
//freemem = (note_schedule = freemem) + 256;
//note_schedule[] = -1337;

<? all_channels("freemem = chan%d.initNoteSchedule(freemem);") ?>
freemem = preview_channel.initNoteSchedule(freemem);
freemem = (blocked_samples = freemem) + N_SAMPLES;
freemem = (muted_samples = freemem) + N_SAMPLES;
freemem = (solod_samples = freemem) + N_SAMPLES;

freemem = (autosplits = freemem) + 128;
freemem = build_all_sinc_tables(freemem);

@slider
interpolation > 2 ? (pdc_delay = 24; pdc_bot_ch = 0; pdc_top_ch = 17;);
freemem = build_all_sinc_tables(sinc_tables);

@serialize
writing = file_avail(0) < 0;
loaded = 1;
file_var(0, version);
serialize_all_samples(writing);
file_mem(0, muted_samples, N_SAMPLES);
file_mem(0, solod_samples, N_SAMPLES);
update_mute_status();

@block
midi.processMIDIBlock();

@sample
samples_per_beat = floor((srate * 60) / tempo / ticks_per_beat);

function processMIDISample()
local(channel)
instance(notePtr, remainingNotes, nextNote, curSample)
(
  // Take notes from the stack until we hit the end marker -1
  (remainingNotes) ? (
    // This handleMessages is ugly, but if we don't do this, we're going
    // to be checking this every cycle where there is any MIDI in the block => Not good.
    handleMessages = 0;
    (nextNote == curSample) ? (
      handleMessages = 1;
      <? all_channels("chan%d.prepare_channel_for_messages();") ?>
    );
  
    while(nextNote == curSample) (
      notePtr += 1;
      
      channel = notePtr[];
      (channel == 0) ? ( 0 ) 
      <? all_channels(": (channel == %d) ? ( chan%d.handle_message(notePtr[1], notePtr[2], notePtr[3]); )") ?>;
      notePtr += 4;
      
      // Avoid constantly dereferencing by picking up the next one
      nextNote = notePtr[];
      remainingNotes = nextNote != -1337;
    );
    
    handleMessages ? (
      <? all_channels("chan%d.commit_note();") ?>
    );
  );
  
  curSample += 1;
);
ssl = ssr = 0;

midi.processMIDISample();

multi_out ? (
  /* TODO: clean this up */
  chan1.playing ? (ssl = ssr = 0; chan1.play_channel(); spl0 = ssl; spl1 = ssr;);
  chan2.playing ? (ssl = ssr = 0; chan2.play_channel(); spl2 = ssl; spl3 = ssr;);
  chan3.playing ? (ssl = ssr = 0; chan3.play_channel(); spl4 = ssl; spl5 = ssr;);
  chan4.playing ? (ssl = ssr = 0; chan4.play_channel(); spl6 = ssl; spl7 = ssr;);
  chan5.playing ? (ssl = ssr = 0; chan5.play_channel(); spl8 = ssl; spl9 = ssr;);
  chan6.playing ? (ssl = ssr = 0; chan6.play_channel(); spl10 = ssl; spl11 = ssr);
  chan7.playing ? (ssl = ssr = 0; chan7.play_channel(); spl12 = ssl; spl13 = ssr;);
  chan8.playing ? (ssl = ssr = 0; chan8.play_channel(); spl14 = ssl; spl15 = ssr;);
  chan9.playing ? (ssl = ssr = 0; chan9.play_channel(); spl16 = ssl; spl17 = ssr;);
  chan10.playing ? (ssl = ssr = 0; chan10.play_channel(); spl18 = ssl; spl19 = ssr;);
  chan11.playing ? (ssl = ssr = 0; chan11.play_channel(); spl20 = ssl; spl21 = ssr;);
  chan12.playing ? (ssl = ssr = 0; chan12.play_channel(); spl22 = ssl; spl23 = ssr;);
  chan13.playing ? (ssl = ssr = 0; chan13.play_channel(); spl24 = ssl; spl25 = ssr;);
  chan14.playing ? (ssl = ssr = 0; chan14.play_channel(); spl26 = ssl; spl27 = ssr;);
  chan15.playing ? (ssl = ssr = 0; chan15.play_channel(); spl28 = ssl; spl29 = ssr;);
  chan16.playing ? (ssl = ssr = 0; chan16.play_channel(); spl30 = ssl; spl31 = ssr;);
  
  ssl = ssr = 0; 
  preview_channel.play_channel();
  spl0 += ssl;
  spl1 += ssr;
) : (
  <? all_channels("chan%d.playing ? chan%d.play_channel();") ?>
  preview_channel.play_channel();
  spl0 += ssl;
  spl1 += ssr;
);

@gfx
over_pad = -1;
SAMPLE_FONT = 5;
TINY_FONT = 6;
gfx_setfont(TINY_FONT, "Arial", 12);
BIG_FONT = 7;
gfx_setfont(BIG_FONT, "Arial", 18);

handle_dropped_files();
current_char = gfx_getchar();
handle_gmem_imports();

function handle_play_stop(x, y, w, h, idx)
local(bh, bw)
global(TINY_FONT, last_cap, mouse_cap, captured,
       preview_channel.play_sample, preview_channel.stop_sample)
(
  bw = 30;
  bh = 15;
  control_rect(x, y + h - bh, bw, bh, 0.04, 0.07, 0.03, 1.0, TINY_FONT, "Play", 0) ? (
    ((last_cap & 1) == 0) && (mouse_cap & 1) && !captured ? (
      preview_channel.play_sample(idx, 69, 0);
    );
  );
    
  control_rect(x + bw, y + h - bh, bw, bh, 0.07, 0.04, 0.03, 1.0, TINY_FONT, "Stop", 0) ? (
    ((last_cap & 1) == 0) && (mouse_cap & 1) && !captured ? (
      preview_channel.stop_sample();
    );
  );
);

// Are we playing anything?
new_pitch = get_pitch_from_kb(current_char);
((new_pitch > -1) && (wait_for_release != current_char) && gfx_getchar(current_char)) ? (
  preview_channel.play_sample(selected_sample, new_pitch + 69 - 24, 0);
  preview_offset = min(close_up.block_start, close_up.block_end);
  preview_offset > 0 ? (
    preview_channel.set_offset_raw((preview_offset - close_up.sample_start) * 0.5);
  );
  wait_for_release = current_char;
);

(!gfx_getchar(wait_for_release) && (wait_for_release > 0)) ? (
  wait_for_release = 0;
  preview_channel.stop_sample();
);

gfx_pad = 0.01 * gfx_w;

gfx_set(0, 0, 0, 1);
gfx_rect(0, 0, gfx_w, gfx_h);

nx = 6;
ny = 6;
block_pad = 4;
sample_edit_size = 0.3 * gfx_h;
block_width = floor((gfx_w - 2 * gfx_pad - (nx - 2) * block_pad) / nx);
block_height = floor((gfx_h - 2 * gfx_pad - (ny + 1 - 2) * block_pad - sample_edit_size) / ny);

cx = gfx_pad;
cy = gfx_pad;
idx = 0;
loop(ny,
  cx = gfx_pad;
  loop(nx,
    draw_wavebox(cx, cy, block_width, block_height, idx, samplelocs[idx]);
    process_pad(cx, cy, block_width, block_height, idx, samplelocs[idx]);
    process_pad_mute(cx, cy, block_width, block_height, idx, samplelocs[idx]);
    handle_play_stop(cx, cy, block_width, block_height, idx);
    cx += block_width + block_pad;
    idx += 1;
  );
  cy += block_height + block_pad;
);

updated_loop ? (
  updated_loop = 0;
  <? all_channels("channel_update_loop();") ?>
  preview_channel.channel_update_loop();
);

/* Zoomed in waveform */
close_up.draw_sample_big(gfx_pad, cy, gfx_w - 2 * gfx_pad, sample_edit_size, reset_zoom);

function draw_playmarker(sample_idx, rel_pos)
local(x_pos, y_pos)
global(nx, ny, gfx_pad, block_pad, block_width, block_height,
       selected_sample, cy, gfx_w, gfx_pad, sample_edit_size)
(
  y_pos = floor(sample_idx / nx);
  x_pos = sample_idx - y_pos * nx;
  
  x_pos = gfx_pad + (block_width + block_pad) * x_pos;
  y_pos = gfx_pad + (block_height + block_pad) * y_pos;
  gfx_set(1, 1, 1, .03);
  gfx_rect(x_pos, y_pos, block_width, block_height);
  gfx_set(.3, .5, 1, .33);
  gfx_rect(x_pos + rel_pos * block_width - 1, y_pos, 3, block_height);
  gfx_set(.5, .5, 1, 1);
  gfx_rect(x_pos + rel_pos * block_width, y_pos, 1, block_height);
  
  // Also draw in the big preview
  selected_sample == sample_idx ? (
    x_pos = gfx_pad;
    y_pos = cy;
    gfx_set(.3, .5, 1, .33);
    gfx_rect(x_pos + rel_pos * (gfx_w - 2 * gfx_pad) - 1, y_pos, 3, sample_edit_size);
    gfx_set(.5, .5, 1, 1);
    gfx_rect(x_pos + rel_pos * (gfx_w - 2 * gfx_pad), y_pos, 1, sample_edit_size);
  );
);

function draw_markers()
local()
global(samplelocs)
instance(sample_idx, current_playback, play0, play1)
(
  (current_playback == 0) ? (
    play0.playing && (play0.position > 0) ? (
      draw_playmarker(sample_idx, 2 * play0.position / samplelocs[sample_idx][]);
    );
  ) : (
    play1.playing && (play1.position > 0) ? (
      draw_playmarker(sample_idx, 2 * play1.position / samplelocs[sample_idx][]);      
    );
  );
);

<? all_channels("chan%d.draw_markers();") ?>
preview_channel.draw_markers();

sample_data_gfx_finalize();

handle_mouse_sample_handler();

(current_char == 26161) && (last_char != current_char) ? show_hints = 1 - show_hints;

show_hints ? (
gfx_setfont(10, "Arial", floor(gfx_h / 40));
str = 
"Effect List
  
  01 - Portamento up
  02 - Portamento down
    Note that the portamento's behave different from Protracker. In PT you directly
    perform the portamento based on the period of the signal. Portamento is updated
    every N times per row (ticks).
    Here, the portamento slides continuously and the amount is specified in 
    eigth semitones. This means that 08 is 1 semitone. 10 is 2, etc.
    00 continues the last portamento.
  03 - Glide
    Glide to note. Glide speed is specified in 1/16th notes.
    00 Continues a previous glide.
  04 - Vibrato
    X is pitch depth (value from 0 to 7). They are given in seventh semitones.
    Y is speed (value from 0 to F).
      Continue, 128, 64, 32, 24, 16, 12, 8, 6, 5, 4, 3, 2, 1, 0.25, 0.125
    0 continues the previous value.
  08 - Panning
    Panning.
  09 - Set offset
    Unlike the classic Protracker, this sets offset as fraction of the sample length.
    Since 7F (127) is the maximum in MIDI; 40 is the middle of the sample, 20 1/4th etc.
  0A - Arpeggiator
    Arpeggiate. X and Y are note offsets in semitones. 0 continues previous value.
  0B - Retrigger
    Retrigger note.
    X - Volume reduction per trigger
    Y - Retrigger count
  0C - Sample probability
  60 - Reverse
    Reverses playhead if effect value is 00. Note that if this effect is applied on a 
    note start, it plays the sample from the end. If the effect is started from anywhere 
    else, it will simply reverse the playhead. When the effect is used with 01, hackey 
    tracker playback will return to forward playing.
";
bx = by = 10;
gfx_measurestr(str, ww, hh);
gfx_set(0, 0, 0, 0.9);
gfx_rect(bx, by, ww + 2 * bx, hh + 2 * by);
gfx_set(1, 1, 1, 1);
gfx_x = 2 * bx;
gfx_y = 2 * by;
gfx_printf(str);
);

last_char = current_char;

/*
gfx_x = gfx_y = 0;
gfx_set(1, 1, 1, 1);
gfx_printf(DROPPED_FILE_STR);
*/

hinter.drawhint();
old_time = new_time;
new_time = time_precise();
delta_time = new_time - old_time;

